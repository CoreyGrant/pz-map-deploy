<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>* {
    box-sizing: border-box;
    font-family: "Roboto";
    font-size: 16px;
}

legend{
    font-size: 1.5em;
}
a{
    font-size: 1em;
}
input, select, label, button, textarea{
    font-size: 1em;
}

#svg-container {
    width: 100vw;
    height: 100vh;
    position: relative;
    display: flex;
}
fieldset{
    border: 0.125em solid black;
}
fieldset.collapsed {
    padding-top: 0.25em !important;
    padding-bottom: 0.25em !important;

}

fieldset.collapsed *:not(legend) {
    display: none !important;
}
svg {
    height: 100vh;
    width: 100vw;
}
#version-selector{
    position: absolute;
    top: 0.5em;
    left: 0.5em;
}
#sidebar {
    position: absolute;
    border: 0.125em solid black;
    right: 0.5em;
    top: 0.5em;
    height: calc(100vh - 1em);
    width: 20em;
    background-color: rgb(216, 211, 185);
    display: flex;
    flex-direction: column;
    align-items: center;
}
#pop-over {
    height: 50%;
}

#pop-over-default {
    height: 50%;
}

#pop-over-default p {
    margin: 0;
    font-size: 1.75em;
}

body {
    background-color: rgb(216, 211, 185);
    margin: 0;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
}

option{
    font-family: "Roboto";
}

#pop-over-checkboxes{
    display: flex;
    flex-direction: row;
    justify-content: space-between;
}

#pop-over-name {
    font-size: 1.5em;
    margin: 0;
    margin-bottom: 0.125em;
}
#pop-over-notes-container {
    display: flex;
    flex-direction: column;
}

#pop-over-notes {
    height: 9em;
    resize: none;
}

#pop-over-rooms{
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    overflow-y: auto;
    max-height: 10em;
    margin-top: 0.5em;
    padding: -0.25em;
}

.chip {
    padding: 0.25em;
    margin-right: 0.25em;
    margin-bottom: 0.25em;
    border: 0.0625em solid black;
    border-radius: 0.5em;
    font-size: 0.875em;
    cursor: pointer;
}

.chip.checkbox-chip {
    padding: 0.25em;
    margin-right: 0.25em;
    margin-bottom: 0.25em;
    border: 0.0625em solid black;
    border-radius: 0.5em;
    font-size: 1em;
    display: flex;
    justify-content: space-between;
}
.chip.checkbox-chip > label {
    margin-right: 0.125em;
    cursor: pointer;
}
.chip.checkbox-chip>label>span{
    font-size: 1em;
}
.chip.checkbox-chip > input[type="checkbox"] {
    margin: 0;
    margin-top: 0.1em;
    height: 1em;
    width: 1em;
    cursor: pointer;
}

#pop-over-notes-container label {
    font-size: 1.5em;
}

input[type="checkbox"] {
    height: 1.25em;
    width: 1.25em;
}

#map-control {
    font-size: 2em;
    width: 9em;
    height: 7em;
    padding: 0.5em;
    margin-left: 0.5em;
    margin-right: 0.5em;
    position: relative;
    margin-top: auto;
}

#map-control button {
    font-size: 1em;
    border-radius: 0;
}

#map-control button span{
    font-size: 1em;
}

#map-control-up, #map-control-down, #map-control-left, #map-control-right, #map-control-in, #map-control-out {
    position: absolute;
}

#map-control-up, #map-control-down, #map-control-left, #map-control-right {
    width: 2em;
    height: 2em;
}

#map-control-in, #map-control-out {
    width: 2em;
    height: 3em;
}

#map-control-up {
    top: 0.5em;
    left: 2.5em;
}

#map-control-down {
    top: 4.5em;
    left: 2.5em;
}

#map-control-left {
    left: 0.5em;
    top: 2.5em;
}

#map-control-right {
    left: 4.5em;
    top: 2.5em;
}

#map-control-in {
    left: 6.5em;
    top: 0.5em;
}

#map-control-out {
    left: 6.5em;
    top: 3.5em;
}

#save-manager {
    flex-direction: column;
}

#save-manager-select{
    min-width: 10em;
}

#save-manager-new{
    display: flex;
}
legend{
    cursor: pointer;
}

#save-manager-new label{
}

#save-manager-new input{
    width: 12.5em;
}

#toolbar {
    flex-direction: column;
}
#toolbar > div{
    display: flex;
}

.sidebar-section {
    display: flex;
    padding: 0.5em;
    width: calc(100% - 1em);
    margin-left: 0.5em;
    margin-right: 0.5em;
}

.fieldset-form {
    position: relative;
    display: flex;
    width: 100%;
}
.fieldset-form input[type="text"],
.fieldset-form select {
    width: 100%;
}
.fieldset-form .actions {
    position: absolute;
    top: -2.125em;
    right: 0;
    display: flex;
    align-items: center;
}
.fieldset-form .actions button {
    border: 0.0625em solid black;
    border-radius: 0.75em;
    width: 2.5em;
    height: 1.5em;
    background-color: rgb(216, 211, 185);
    margin-left: 0.5em;
    cursor: pointer;
}
.fieldset-form .actions button span {
    font-size: 1.5em;
    line-height: 0.875em;
    cursor: pointer;
}
.fieldset-form .add {
    
}

.fieldset-form .remove {
} 

</style>
    <style>@media (max-width: 1200px) {
    * {
        font-size: 14px;
    }
}
@media (max-width: 992px) {
    * {
        font-size: 13px;
    }
}
@media (max-width: 768px) {
    * {
        font-size: 12px;
    }
}
@media (max-width: 480px) {
    * {
        font-size: 10px;
    }
}
@media (max-width: 320px) {
    * {
        font-size: 8px;
    }
}
</style>
    <title>PZ Build 41 Map</title>
</head>
<body>
    <div id="svg-container">
        <div id="version-selector">
            <select id="version-selector-select">

            </select>
        </div>
        <div id="sidebar">
            <div id="pop-over-default" class="sidebar-section">
                <p>Select a building</p>
            </div>
            <div id="pop-over" style="display: none" class="sidebar-section">
                <p id="pop-over-name"></p>
                <div id="pop-over-checkboxes">
                    <div id="pop-over-survivor" class="chip checkbox-chip">
                        <label for="pop-over-survivor-input"><span style="text-decoration: underline">S</span>urvivor</label>
                        <input type="checkbox" id="pop-over-survivor-input" />
                    </div>
                    <div id="pop-over-looted" class="chip checkbox-chip">
                        <label for="pop-over-looted-input"><span style="text-decoration: underline">L</span>ooted</label>
                        <input type="checkbox" id="pop-over-looted-input" />
                    </div>
                    <div id="pop-over-base" class="chip checkbox-chip">
                        <label for="pop-over-base-input"><span style="text-decoration: underline">B</span>ase</label>
                        <input type="checkbox" id="pop-over-base-input" />
                    </div>
                </div>
                <div id="pop-over-notes-container">
                    <label for="pop-over-notes">Notes</label>
                    <textarea id="pop-over-notes"></textarea>
                </div>
                <div id="pop-over-rooms">

                </div>
            </div>
            <fieldset id="save-manager" class="sidebar-section">
                <legend>Save</legend>
                <div id="save-manager-new-container" class="fieldset-form">
                    <select id="save-manager-select"></select>
                    <div id="save-manager-show-new" class="actions">
                        <button id="save-manager-show-new-remove" title="Remove"><span>&#x1F5D1;</span></button>
                        <button id="save-manager-show-new-add" title="Add"><span>+</span></button>
                    </div>
                </div>
                <div id="save-manager-new" class="fieldset-form" style="display: none">
                    <input type="text" />
                    <div class="actions">
                        <button id="save-manager-new-cancel" class="remove"><span>&#x21BA;</span></button>
                        <button id="save-manager-new-save"><span>&#x0001f4be;</span></button>
                    </div>
                </div>
            </fieldset>
            <fieldset id="toolbar" class="sidebar-section">
                <legend>Add text</legend>
                <div class="fieldset-form">
                    <input type="text" id="toolbar-input" />
                    <div class="actions">
                        <button id="toolbar-button" title="Add"><span>+</span></button>
                    </div>
                </div>
                <div>
                    <select id="toolbar-size">
                        <option value="12px">Tiny</option>
                        <option value="18px" selected>Small</option>
                        <option value="24px">Medium</option>
                        <option value="40px">Large</option>
                        <option value="72px">Huge</option>
                    </select>
                    <input type="color" id="toolbar-color"/>
                </div>
            </fieldset>
            <fieldset id="locator" class="sidebar-section">
                <legend>Room Locator</legend>
                <div class="fieldset-form">
                    <select id="locator-select"></select>
                    <div class="actions">
                        <button id="locator-button">&#x1F50D;</button>
                    </div>
                </div>
            </fieldset>
        </div>
    </div>
    
    <script>(function () {
    class QueryState {
        state;
        constructor() {
            this.loadQuery();
        }

        loadQuery() {
            const query = window.location.search;
            const parts = query.substring(1).split("&");
            const state = {};
            for (var part of parts) {
                if (!part.length) { continue;s }
                const keyValue = part.split("=");
                const key = keyValue[0];
                const value = keyValue[1];
                state[key] = value;
            }
            this.state = state;
        }

        updateQuery(newStateObj) {
            Object.assign(this.state, newStateObj);
            let newState = "?";
            for (var stateKey in this.state) {
                if (!stateKey || !stateKey.length) { continue; }
                var stateValue = this.state[stateKey];
                newState += stateKey + "=" + stateValue + "&";
            }
            window.history.replaceState(
                null,
                "",
                window.location.pathname + newState.substring(0, newState.length - 1));
        }
    }

    window.QueryState = QueryState;

}())</script>
    <script>
(function() {
    const mapConfig = {
        width: 0,
        height: 0,
        zoomLevels: [],
        zoomFunction: undefined,
        initialZoom: 0,
        controls: {
            keys: true,
            mouse: true,
            buttons: true
        }
    }
    function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => { func.apply(this, args); }, timeout);
        };
    }
    class MapSvg {
        svg;
        mapConfig;
        zoomLevels;
        zoom;
        centreX;
        centreY;
        pt;
        constructor(svg, mapConfig, queryState) {
            this.svg = svg;
            this.pt = svg.createSVGPoint();
            this.mapConfig = mapConfig;
            this.queryState = queryState;
            this.initFromConfig(mapConfig);
            this.loadQuery();
            this.updateViewbox(true);
        }

        zoomOut() {
            this.zoom = Math.max(this.zoom - 1, 0);
            this.updateViewbox();
        }

        zoomIn() {
            this.zoom = Math.min(this.zoom + 1, this.zoomLevels.length - 1);
            this.updateViewbox();
        }

        updateViewbox(leaveState) {
            if (!leaveState) {
                this.debouncedUpdateQuery();
            }
            const viewBox = this.calculateViewbox();
            this.svg.setAttribute(
                "viewBox",
                viewBox);
        }

        pan(x, y) {
            var zoomModifier = this.zoomLevels[this.zoom];
            this.centreX += this.zoomScale(x * 2000);
            this.centreY += this.zoomScale(y * 2000);
            this.updateViewbox();
        }
        viewboxX;
        viewboxY;
        viewboxWidth;
        viewboxHeight;
        calculateViewbox() {
            var zoomModifier = this.zoomLevels[this.zoom];
            this.viewboxWidth = +this.zoomScale(this.mapConfig.width).toFixed();
            this.viewboxHeight = +this.zoomScale(this.mapConfig.height).toFixed();
            this.viewboxX = +(this.centreX - this.viewboxWidth / 2 ).toFixed();
            this.viewboxY = +(this.centreY - this.viewboxHeight / 2).toFixed();
            return `${this.viewboxX} ${this.viewboxY} ${this.viewboxWidth} ${this.viewboxHeight}`;
        }

        initFromConfig(mapConfig) {
            this.zoom = mapConfig.initialZoom;
            let zoomLevels = mapConfig.zoomLevels;
            if (mapConfig.zoomFunction) {
                zoomLevels = zoomLevels.map(mapConfig.zoomFunction);
            }
            this.zoomLevels = zoomLevels;
            this.centreX = this.zoomScale(this.mapConfig.width);
            this.centreY = this.zoomScale(this.mapConfig.height);

            const controls = mapConfig.controls || {};

            if (controls.keys) { this.initKeyControls(); }
            if (controls.mouse) { this.initMouseControls(); }
            if (controls.buttons) { this.initButtonControls(); }
        }

        initButtonControls() {
            const existing = document.getElementById("map-control");
            if (existing) { existing.remove(); }
            const mapControl = document.createElement("div");
            mapControl.id = "map-control";
            function setElm(elm, id, text, onClick) {
                const innerSpan = document.createElement("span");
                innerSpan.innerHTML = text;
                elm.id = id;
                elm.appendChild(innerSpan);
                elm.addEventListener("click", () => onClick());
            }
            const panUp = document.createElement("button");
            setElm(panUp, "map-control-up", "&uarr;", () => this.pan(0, -1));

            const panDown = document.createElement("button");
            setElm(panDown, "map-control-down", "&darr;", () => this.pan(0, 1));

            const panLeft = document.createElement("button");
            setElm(panLeft, "map-control-left", "&larr;", () => this.pan(-1, 0));

            const panRight = document.createElement("button");
            setElm(panRight, "map-control-right", "&rarr;", () => this.pan(1, 0));

            const zoomIn = document.createElement("button");
            setElm(zoomIn, "map-control-in", "+", () => this.zoomIn());

            const zoomOut = document.createElement("button");
            setElm(zoomOut, "map-control-out", "-", () => this.zoomOut());

            mapControl.appendChild(panUp);
            mapControl.appendChild(panDown);
            mapControl.appendChild(panLeft);
            mapControl.appendChild(panRight);
            mapControl.appendChild(zoomIn);
            mapControl.appendChild(zoomOut);

            document.getElementById("sidebar").appendChild(mapControl);
        }

        initKeyControls() {
            document.addEventListener("keydown", (ev) => {
                switch (ev.key) {
                    case "ArrowDown":
                        this.pan(0, 1);
                        break;
                    case "ArrowUp":
                        this.pan(0, -1);
                        break;
                    case "ArrowLeft":
                        this.pan(-1, 0);
                        break;
                    case "ArrowRight":
                        this.pan(1, 0);
                        break;
                    case "+":
                        this.zoomIn();
                        break;
                    case "-":
                        this.zoomOut();
                        break;
                }
            });
        }

        mousedown;
        mousedownPosLast;
        pinchZoomStart;
        lastPinchZoom;
        initMouseControls() {
            
            this.svg.addEventListener("wheel", (ev) => {
                var scaledPos = this.scaleScreenToSvgAbsolute({ x: ev.clientX, y: ev.clientY });
                this.centreX = scaledPos.x;
                this.centreY = scaledPos.y;
                if (ev.deltaY > 0) {
                    this.zoomOut();
                } else {
                    this.zoomIn();
                }
            });
            this.svg.addEventListener("mousedown", (ev) => {
                if (ev.button == 0) {
                    this.mousedown = true;
                    this.mousedownPosLast = { x: ev.clientX, y: ev.clientY };
                }
            });
            this.svg.addEventListener("mousemove", (ev) => {
                if (this.mousedown && this.mousedownPosLast) {
                    const currentPos = { x: ev.clientX, y: ev.clientY };
                    const baseDiff = {
                        x: this.mousedownPosLast.x - currentPos.x,
                        y: this.mousedownPosLast.y - currentPos.y
                    }
                    if (baseDiff.x * baseDiff.x + baseDiff.y * baseDiff.y < 9) {
                        return;
                    } 
                    const diff = this.scaleScreenToSvg(baseDiff, true);
                    this.centreX += (diff.x);
                    this.centreY += (diff.y);
                    this.updateViewbox();
                    this.mousedownPosLast = currentPos;
                }
            });
            document.addEventListener("mouseup", (ev) => {
                this.mousedown = false;
                this.mousedownPosLast = undefined;
            });

            this.svg.addEventListener("touchstart", (ev) => {
                this.mousedown = true;
                if (ev.touches.length == 1) {
                    var touch = ev.touches[0];
                    this.mousedownPosLast = { x: touch.clientX, y: touch.clientY };
                } else if (ev.touches.length == 2) {
                    this.pinchZoomStart = ev.touches.map(x => ({ x: x.clientX, y: x.clientY }));
                    ev.preventDefault();
                }
            });
            this.svg.addEventListener("touchmove", (ev) => {
                if (this.mousedown) {
                    if (ev.touches.length == 1) {
                        var touch = ev.touches[0];
                        const currentPos = { x: touch.clientX, y: touch.clientY };
                        const baseDiff = {
                            x: this.mousedownPosLast.x - currentPos.x,
                            y: this.mousedownPosLast.y - currentPos.y
                        }
                        if (baseDiff.x * baseDiff.x + baseDiff.y * baseDiff.y < 9) {
                            return;
                        }
                        const diff = this.scaleScreenToSvg(baseDiff, true);
                        this.centreX += (diff.x);
                        this.centreY += (diff.y);
                        this.updateViewbox();
                        this.mousedownPosLast = currentPos;
                        ev.preventDefault();
                    } else if (ev.touches.length == 2) {
                        this.lastPinchZoom = ev.touches.map(x => ({ x: x.clientX, y: x.clientY }));
                        ev.preventDefault();
                    }
                }
            });
            document.addEventListener("touchend", (ev) => {
                this.mousedown = false;
                this.mousedownPosLast = undefined;
                if (this.pinchZoomStart && this.lastPinchZoom) {
                    const start1 = this.pinchZoomStart[0];
                    const start2 = this.pinchZoomStart[1];
                    const startXDiff = start1.x - start2.x;
                    const startYDiff = start1.y - start2.y;
                    const startDistance = startXDiff * startXDiff + startYDiff * startYDiff;

                    const end1 = this.lastPinchZoom[0];
                    const end2 = this.lastPinchZoom[1];
                    const endXDiff = end1.x - end2.x;
                    const endYDiff = end1.y - end2.y;
                    const endDistance = endXDiff * endXDiff + endYDiff * endYDiff;

                    if (startDistance > endDistance) { this.zoomIn(); }
                    if (startDistance < endDistance) { this.zoomOut(); }

                    this.pinchZoomStart = undefined;
                    this.lastPinchZoom = undefined;
                }
            });
        }

        scaleScreenToSvg({ x, y }, panning) {
            const abs = this.scaleScreenToSvgAbsolute({ x, y });
            this.pt.x = 0;
            this.pt.y = 0;
            const topLeft = this.pt.matrixTransform(this.svg.getScreenCTM().inverse());
            return {
                x: abs.x - topLeft.x,
                y: abs.y - topLeft.y
            };
        }

        scaleScreenToSvgAbsolute({ x, y }) {
            this.pt.x = x;
            this.pt.y = y;
            const scaled = this.pt.matrixTransform(this.svg.getScreenCTM().inverse());
            return { x: scaled.x, y: scaled.y };
        }

        loadQuery() {
            const queryState = this.queryState.state;
            let change = false;
            for (const name in queryState) {
                const value = queryState[name];
                if (name.toLowerCase() == "centrex") {
                    this.centreX = +value;
                    change = true;
                } else if (name.toLowerCase() == "centrey") {
                    this.centreY = +value;
                    change = true;
                } else if (name.toLowerCase() == "zoom") {
                    let zoom = Math.floor(+value);
                    if (zoom > this.zoomLevels.length - 1) {
                        zoom = this.zoomLevels.length - 1;
                    }
                    if (zoom < 0) { zoom = 0; }
                    this.zoom = zoom;
                    change = true;
                }
            }
            if (change) {
                this.updateViewbox(true);
            }
        }
        debouncedUpdateQuery = debounce.bind(this)(this.updateQuery);
        updateQuery() {
            const newState = {
                centreX: this.centreX.toFixed(0),
                centreY: this.centreY.toFixed(0),
                zoom: this.zoom
            };
            this.queryState.updateQuery(newState);
        }

        zoomScale(val) {
            const zoomModifier = this.zoomLevels[this.zoom];
            return val / zoomModifier;
        }
    }

    window.MapSvg = MapSvg;
}())</script>
    <script>(function() {
    class SaveManager {
        stateManager;
        polygonManager;
        popover;
        saveManagerNew;
        saveManagerShowNew;
        saveManagerShowNewAdd;
        saveManagerShowNewRemove;
        newSaveInput;
        newSaveButton;
        newCancelButton;
        saveSelect;
        constructor(stateManager, popover, polygonManager) {
            this.stateManager = stateManager;
            this.popover = popover;
            this.polygonManager = polygonManager;
            this.newSaveInput = document.querySelector("#save-manager-new input");
            this.newSaveButton = document.querySelector("#save-manager-new-save");
            this.newCancelButton = document.querySelector("#save-manager-new-cancel");
            this.saveSelect = document.getElementById("save-manager-select");
            this.saveManagerShowNew = document.getElementById("save-manager-show-new");
            this.saveManagerShowNewAdd = document.getElementById("save-manager-show-new-add");
            this.saveManagerShowNewRemove = document.getElementById("save-manager-show-new-remove");
            this.saveManagerNew = document.getElementById("save-manager-new");
            const currentSave = this.stateManager.getLastSave();
            this.newSaveButton.addEventListener("click", () => this.addNewSave());
            this.setSelectOptions(currentSave);
            this.saveSelect.addEventListener("change", (e) => this.loadSave(e.target.value));
            this.saveManagerShowNewAdd.addEventListener("click", () => this.showNew());
            this.saveManagerShowNewRemove.addEventListener("click", () => this.remove());
            this.newCancelButton.addEventListener("click", () => this.cancel());
        }
        onChange(oldState) {
            this.popover.hide();
            const newState = this.stateManager.getState();
            Object.keys(oldState).forEach(id =>
                this.polygonManager.updatePolygon(id, oldState, true));
            Object.keys(newState).forEach(id =>
                this.polygonManager.updatePolygon(id, newState));
        }
        showNew() {
            this.saveManagerNew.style.display = "initial";
            this.saveSelect.style.display = "none";
            this.saveManagerShowNew.style.display = "none";
            this.popover.hide();
        }
        addNewSave() {
            const oldState = this.stateManager.getState();
            const inputValue = this.newSaveInput.value;
            if (!inputValue || !inputValue.length || inputValue === "default" || inputValue === "last-save") {
                return;
            }
            this.newSaveInput.value = "";
            const currentSave = this.saveSelect.value;
            if (currentSave === "default") {
                this.stateManager.renameDefaultSave(inputValue);
            }
            this.stateManager.saveLastSave(inputValue);
            this.setSelectOptions(inputValue);
            this.saveManagerNew.style.display = "none";
            this.saveSelect.style.display = "initial";
            this.saveManagerShowNew.style.display = "initial";
            this.onChange(oldState);
        }
        cancel() {
            this.newSaveInput.value = "";
            this.saveManagerNew.style.display = "none";
            this.saveSelect.style.display = "initial";
            this.saveManagerShowNew.style.display = "initial";
        }
        remove() {
            const oldState = this.stateManager.getState();
            const saveToRemove = this.saveSelect.value;
            if (saveToRemove == "default") { return; }
            const confirmed = confirm("Are you sure you want to delete " + saveToRemove);
            if (!confirmed) { return; }
            const newSaveKey = this.stateManager.removeSave(saveToRemove);
            this.setSelectOptions(newSaveKey);
            this.onChange(oldState);
        }
        loadSave(value) {
            const oldState = this.stateManager.getState();
            this.stateManager.saveLastSave(value);
            this.onChange(oldState);
        }
        setSelectOptions(initialValue) {
            let allSaves = this.stateManager.getSaves();
            if (!allSaves.length) { allSaves = ["default"]; }
            this.saveSelect.innerHTML = "";
            for (var save of allSaves) {
                const option = document.createElement("option");
                option.innerHTML = save;
                option.value = save;
                if (save == initialValue) {
                    option.selected = true;
                }
                this.saveSelect.appendChild(option);
            }
        }
    }

    window.SaveManager = SaveManager;

}())</script>
    <script>(function () {
    const appName = "pz-map";
    class StateManager{
        appState;
        version;
        constructor(version) {
            this.version = version;
            this.appState = JSON.parse(localStorage.getItem(appName + "-" + version)
                ?? "{\"saves\": {}}");
            this.appState.lastSave = this.getLastSave();
            const currentState = this.getState();
            if (!currentState) {
                this.appState.saves[this.appState.lastSave] = {};
            }
            this.saveState();
        }
        getState() {
            if (!this.appState.saves[this.appState.lastSave]) {
                this.appState.saves[this.appState.lastSave] = {};
                this.saveState();
            }
            return this.appState.saves[this.appState.lastSave];
        }
        saveState() {
            localStorage.setItem(appName + "-" + this.version, JSON.stringify(this.appState));
        }
        
        removeStateItem(id) {
            delete this.appState.saves[this.appState.lastSave][id];
            this.saveState();
        }
        upsertStateItem(id, key, value) {
            if (!this.appState.saves[this.appState.lastSave][id]) {
                this.appState.saves[this.appState.lastSave][id] = {};
            }
            this.appState.saves[this.appState.lastSave][id][key] = value;
            this.saveState();
        }
        // Last save management
        getLastSave() {
            if (this.appState.lastSave && this.appState.lastSave.length) {
                return this.appState.lastSave;
            }
            return "default";
        }
        saveLastSave(lastSave) {
            this.appState.lastSave = lastSave;
            this.saveState();
        }
        // Default save
        renameDefaultSave(newName) {
            this.appState.saves[newName] = this.appState.saves["default"];
            delete this.appState.saves["default"];
            this.saveState();
        }

        getSaves() {
            return Object.keys(this.appState.saves);
        }
        removeSave(name) {
            delete this.appState.saves[name];
            const otherSaves = Object.keys(this.appState.saves);
            console.log("removing save", { name, otherSaves });
            if (otherSaves.length == 0) {
                this.appState.lastSave = "default";
            } else {
                this.appState.lastSave = otherSaves[0];
            }
            this.saveLastSave(this.appState.lastSave);
            return this.appState.lastSave;
        }
    }

    //class StateManager {
    //    appState;
    //    state;
    //    saveKey;
    //    appName = "pz-map";
    //    constructor(saveKey) {
    //        this.appState = JSON.parse(localStorage.getItem(this.appName) ?? "{}");
    //        this.saveKey = saveKey ?? this.getLastSave();
    //        this.state = this.loadState();
    //    }
    //    upsertStateItem(id, key, value) {
    //        if (!this.state[id]) { this.state[id] = {} }
    //        const item = this.state[id];
    //        item[key] = value;
    //        this.saveState();
    //    }
    //    removeStateItem(id) {
    //        delete this.state[id];
    //        this.saveState();
    //    }
    //    saveState() {
    //        this.appState[this.saveKey] = this.state;
    //        localStorage.setItem(this.appName, JSON.stringify(this.appState));
    //    }

    //    loadState() {
    //        if (!this.appState[this.saveKey]) {
    //            this.appState[this.saveKey] = {};
    //        }
            
    //        return this.appState[this.saveKey];
    //    }
    //    getLastSave() {
    //        var lastSaveItem = localStorage.getItem("last-save");
    //        if (lastSaveItem && lastSaveItem.length) {
    //            return lastSaveItem;
    //        }
    //        return "default";
    //    }
    //    saveLastSave(lastStateItem) {
    //        localStorage.setItem("last-save", lastStateItem);
    //    }
    //    renameDefaultSave(newName) {
    //        var defaultItem = localStorage.getItem("default");
    //        localStorage.setItem(newName, defaultItem);
    //        localStorage.removeItem("default");
    //    }
    //    getSaves() {
    //        var saves = Object.keys(localStorage)
    //            .filter(x => x !== "last-save");
    //        return saves;
    //    }
    //    removeSave(name) {
    //        localStorage.removeItem(name);
    //        const otherSaves = Object.keys(localStorage).filter(x => x !== 'last-save');
    //        if (otherSaves.length == 0) {
    //            this.saveKey = "default";
    //        } else {
    //            this.saveKey = otherSaves[0];
    //        }
    //        this.saveLastSave(this.saveKey);
    //        this.state = this.loadState();
    //        return this.saveKey;
    //    }
    //}

    window.StateManager = StateManager;
} ())</script>
    <script>
(function () {
    class Popover {
        popover;
        popoverDefault;
        popoverName;
        popoverSurvivorCheckbox;
        popoverLootedCheckbox;
        popoverBaseCheckbox;
        popoverNotes;
        popoverRooms;
        svg;
        locked = false;
        stateManager;
        metadata;
        id;
        polygonManager;
        locator;
        constructor(svg, stateManager, metadata, polygonManager, locator, info) {
            this.info = info;
            this.svg = svg;
            this.polygonManager = polygonManager;
            this.locator = locator;
            this.popover = document.getElementById("pop-over");
            this.popoverDefault = document.getElementById("pop-over-default");
            this.popoverName = document.getElementById("pop-over-name");
            this.popoverSurvivorCheckbox = document.getElementById("pop-over-survivor")
                .getElementsByTagName("input")[0];
            this.popoverLootedCheckbox = document.getElementById("pop-over-looted")
                .getElementsByTagName("input")[0];
            this.popoverBaseCheckbox = document.getElementById("pop-over-base")
                .getElementsByTagName("input")[0];
            this.popoverNotes = document.getElementById("pop-over-notes");
            this.popoverRooms = document.getElementById("pop-over-rooms");
            this.stateManager = stateManager;
            this.metadata = metadata;

            this.popoverLootedCheckbox.addEventListener("change", (ev) => {
                this.stateManager.upsertStateItem(this.id, "looted", ev.target.checked);
                this.polygonManager.updatePolygon(this.id, this.stateManager.getState());
            });

            this.popoverSurvivorCheckbox.addEventListener("change", (ev) => {
                this.stateManager.upsertStateItem(this.id, "survivor", ev.target.checked);
                this.polygonManager.updatePolygon(this.id, this.stateManager.getState());
            });

            this.popoverBaseCheckbox.addEventListener("change", (ev) => {
                this.stateManager.upsertStateItem(this.id, "base", ev.target.checked);
                this.polygonManager.updatePolygon(this.id, this.stateManager.getState());
            });

            this.popoverNotes.addEventListener("input", (ev) => {
                this.stateManager.upsertStateItem(this.id, "notes", ev.target.innerHTML);
                this.polygonManager.updatePolygon(this.id, this.stateManager.getState());
            });
        }

        show(id) {
            this.id = id;
            const polygon = document.getElementById(id);
            const state = this.stateManager.getState();
            const metadataRooms = this.metadata.rooms[id];
            const metadataRoomNames = Object.entries(this.metadata.roomNames)
                .reduce((p, c) => ({...p, [c[1]]: c[0]}) , {});
            const buildingTypeName = this.getName(id);

            const posX = +polygon.getAttribute("x") - this.info.offsetX;
            const posY = +polygon.getAttribute("y") - this.info.offsetY;
            const officialMapUrl = `https://map.projectzomboid.com/#${posX}x${posY}x2000`;
            this.popoverName.innerHTML = buildingTypeName + ` <a target="blank" href="${officialMapUrl}">3d</a>`;

            this.popoverSurvivorCheckbox.checked = state[id]?.survivor ?? false;
            this.popoverLootedCheckbox.checked = state[id]?.looted ?? false;
            this.popoverBaseCheckbox.checked = state[id]?.base ?? false;
            this.popoverNotes.innerHTML = state[id]?.notes ?? "";
            
            this.popoverRooms.innerHTML = "";
            for (var room of metadataRooms) {
                const chip = document.createElement("div");
                chip.className = "chip";
                const roomOption = metadataRoomNames[room];
                const roomCopy = room;
                chip.innerHTML = roomOption;
                chip.addEventListener('click', () => {
                    this.locator.selectOption(roomCopy);
                })
                this.popoverRooms.appendChild(chip);
            }
            // calculate the on-screen position of the polygon
            // put the popover next to it, wherever it fits
            this.popover.style.display = "initial";
            this.popoverDefault.style.display = "none";
            document.addEventListener('keydown', this.keyPressFunc);
        }

        hide() {
            this.popover.style.display = "none";
            this.popoverDefault.style.display = "initial";
            document.removeEventListener('keydown', this.keyPressFunc);
        }
        keyPressFunc = this.keyPress.bind(this);
        keyPress(ev) {
            switch (ev.key) {
                case "s":
                    this.popoverSurvivorCheckbox.checked = !this.popoverSurvivorCheckbox.checked;
                    this.popoverSurvivorCheckbox.dispatchEvent(new Event("change"));
                    break;
                case "b":
                    this.popoverBaseCheckbox.checked = !this.popoverBaseCheckbox.checked;
                    this.popoverBaseCheckbox.dispatchEvent(new Event("change"));
                    break;
                case "l":
                    this.popoverLootedCheckbox.checked = !this.popoverLootedCheckbox.checked;
                    this.popoverLootedCheckbox.dispatchEvent(new Event("change"));
                    break;
            }
        }

        getName(id) {
            const building = document.getElementById(id);
            const buildingType = building.getAttribute("t");
            let typeName;
            //const buildingName = building.getAttribute("n");
            //if (buildingName && buildingName.length) {
            //    return buildingName;
            //}
            if (buildingType == "yes") {
                typeName = "Residential";
            }
            else {
                typeName = buildingType.replace(/([a-z])([A-Z])/g, '$1 $2')
            }
            const buildingFloors = +building.getAttribute("f") || 1;
            const floorsString = buildingFloors == 1 ? "floor" : "floors"
            return typeName + ` (${buildingFloors} ${floorsString})`;
        }
    }

    window.Popover = Popover;
}())

</script>
    <script>(function () {
    // Allows dropping custom svg into the map, linked to specific data
    // So if there is a car which works you can mark it, or a sledge on the ground
    // Or some custom text
    const uid = function (prefix = "") {
        return prefix + "_" + Date.now().toString(36) + Math.random().toString(36).substring(4);
    }

    class Toolbar {
        stateManager;
        toolbar;
        toolbarText;
        toolbarButton;
        svg;
        toolbarTextValue;
        constructor(stateManager, svg, mapSvg, polygonManager) {
            this.stateManager = stateManager;
            this.svg = svg;
            this.toolbar = document.getElementById("toolbar");
            this.toolbarText = document.getElementById("toolbar-input");
            this.toolbarButton = document.getElementById("toolbar-button");
            this.toolbarSizeSelect = document.getElementById("toolbar-size");
            this.toolbarColorSelect = document.getElementById("toolbar-color");
            const svgClick = (e) => {
                const location = { x: +e.clientX.toFixed(), y: +e.clientY.toFixed() };
                var scaled = mapSvg.scaleScreenToSvgAbsolute(location);
                var id = uid("text");
                stateManager.upsertStateItem(id, "text", this.toolbarTextValue);
                stateManager.upsertStateItem(id, "location", scaled);
                stateManager.upsertStateItem(id, "size", this.toolbarSizeSelect.value);
                stateManager.upsertStateItem(id, "color", this.toolbarColorSelect.value);
                stateManager.upsertStateItem(id, "toolbar", true);
                polygonManager.updatePolygon(id, stateManager.getState());
                this.toolbarTextValue = "";
                this.svg.removeEventListener('click', svgClick);
            }

            this.toolbarButton.addEventListener("click", () => {
                this.toolbarTextValue = this.toolbarText.value;
                if (!this.toolbarTextValue || !this.toolbarTextValue.length) {
                    return; 
                }
                this.toolbarText.value = "";
                this.svg.addEventListener('click', svgClick);
            });
        }
    }

    window.Toolbar = Toolbar;
}())</script>
    <script>
(function () {
    class Locator {
        svg;
        rooms;
        roomNames;
        locator;
        locatorSelect;
        locatorButton;
        svgMap;
        constructor(svg, metadata, svgMap) {
            this.svg = svg;
            this.svgMap = svgMap;
            this.rooms = metadata.rooms;
            this.roomNames = metadata.roomNames;
            const roomAmounts = {};
            const roomValues = Object.values(this.rooms);
            for (var roomValue of roomValues) {
                for (var roomIndex of roomValue) {
                    if (!roomAmounts[roomIndex]) { roomAmounts[roomIndex] = 0 }
                    roomAmounts[roomIndex]++;
                }
            }
            this.locator = document.getElementById("locator");
            this.locatorSelect = document.getElementById("locator-select");
            this.locatorButton = document.getElementById("locator-button");
            for (var roomName in this.roomNames) {
                const option = document.createElement("option");
                const value = this.roomNames[roomName];
                option.innerHTML = roomName + " (" + roomAmounts[value] + ")";
                option.value = value
                this.locatorSelect.appendChild(option);
            }

            this.locatorButton.addEventListener("click", () => {
                const value = +this.locatorSelect.value;
                this.showRooms(value);
            });
        }

        showRooms(roomName) {
            let showCounter = 0;
            console.log(this.rooms, roomName);
            var matchingPolygons = Object.keys(this.rooms)
                .filter(x => this.rooms[x].indexOf(roomName) > -1);
            const locations = matchingPolygons
                .map(x => {
                    const polygon = document.getElementById(x);
                    return {
                        x: +polygon.getAttribute("x"),
                        y: +polygon.getAttribute("y")
                    }
                });
            

            let circles = locations.map(x => {
                var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", x.x);
                circle.setAttribute("cy", x.y);
                circle.setAttribute("r", this.svgMap.zoomScale(600));
                circle.setAttribute("fill", "rgba(0,255,0,0.4)");
                circle.setAttribute("stroke", "green");
                circle.setAttribute("stroke-width", this.svgMap.zoomScale(20));
                this.svg.appendChild(circle);
                return circle;
            });
            const timeout = setInterval(() => {
                showCounter++;
                if (showCounter == 30) {
                    clearInterval(timeout);
                    circles.forEach(x => x.remove());
                    return;
                }
                const updatedCounter = this.svgMap.zoomScale(600 - showCounter * 20)
                circles.forEach(x => x.setAttribute("r", updatedCounter));
            }, 33);
        }

        selectOption(value) {
            this.locatorSelect.value = value;
        }
    }

    window.Locator = Locator;
}())
</script>
    <script>(function () {
    function cityName(obj) {
        return Object.assign({
            orientation: "horizontal",
            fontSize: "200px",
            color: "rgba(0,0,0, 0.5)",
        }, obj);
    }
    function townName(obj) {
        return Object.assign({
            orientation: "horizontal",
            fontSize: "120px",
            color: "rgba(0,0,0, 0.5)"
        }, obj);
    }
    const annotations = {
        "41": [
            cityName({
                location: { x: 6500, y: 8280},
                text: "Muldraugh",
            }),
            cityName({
                location: { x: 3100, y: 4250 },
                text: "Riverside",
            }),
            cityName({
                location: { x: 4100, y: 10500 },
                text: "Rosewood",
            }),
            cityName({
                location: { x: 8200, y: 5650 },
                text: "West Point",
            }),
            cityName({
                location: { x: 9600, y: 180 },
                text: "Louisville",
            }),
            cityName({
                location: { x: 6220, y: 11650 },
                text: "March Ridge",
            }),
        ],
        "42": [
            cityName({
                location: { x: 9500, y: 9180},
                text: "Muldraugh",
            }),
            cityName({
                location: { x: 6100, y: 5150 },
                text: "Riverside",
            }),
            cityName({
                location: { x: 7100, y: 11400 },
                text: "Rosewood",
            }),
            cityName({
                location: { x: 11200, y: 6550 },
                text: "West Point",
            }),
            cityName({
                location: { x: 12600, y: 1080 },
                text: "Louisville",
            }),
            cityName({
                location: { x: 9220, y: 12550 },
                text: "March Ridge",
            }),
            cityName({
                location: { x: 1800, y: 5650 },
                text: "Brandenburg"
            }),
            cityName({
                location: { x: 1000, y: 10100 },
                text: "Ekron"
            }),
            cityName({
                location: { x: 1400, y: 14000 },
                text: "Irvington"
            })
        ]
    };
    

    class TextAnnotater {
        svg;
        constructor(svg, version) {
            this.svg = svg;
            for (const annotation of annotations[version.toString()]) {
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", annotation.location.x);
                text.setAttribute("y", annotation.location.y);
                text.innerHTML = annotation.text;
                text.style.fontSize = annotation.fontSize;
                text.style.fill = annotation.color;
                text.style.textOrientation = annotation.orientation;
                text.style.pointerEvents = "none";
                text.style.userSelect = "none";
                this.svg.appendChild(text);
            }
        }
    }

    window.TextAnnotater = TextAnnotater
}())</script>
    <script>(function () {
    class PolygonManager {
        stateManager;
        svg;
        constructor(svg, stateManager) {
            this.stateManager = stateManager;
            this.svg = svg;
            const state = stateManager.getState();
            Object.keys(state)
                .forEach(id => this.updatePolygon(id, state));
        }

        updatePolygon(id, state, reset) {
            if (reset) {
                const polygon = document.getElementById(id);
                if (state[id].toolbar) {
                    polygon.remove();
                    return;
                } 
                polygon.setAttribute("stroke", "rgb(0,0,0)");
                polygon.setAttribute("stroke-dasharray", "none");
                polygon.setAttribute("stroke-width", "1");
                return;
            }
            const stateItem = state[id];
            if (stateItem.toolbar) {
                const text = stateItem.text;
                const location = stateItem.location;
                const size = stateItem.size;
                const color = stateItem.color;
                const textSvgElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
                textSvgElement.innerHTML = text;
                textSvgElement.style.cursor = "pointer";
                textSvgElement.style.fontSize = size;
                textSvgElement.style.fill = color;
                textSvgElement.id = id;
                textSvgElement.setAttribute("title", "Double-click to remove");
                textSvgElement.setAttribute("x", location.x);
                textSvgElement.setAttribute("y", location.y);
                textSvgElement.setAttribute("dominant-baseline", "middle");
                textSvgElement.setAttribute("text-anchor", "middle");
                this.svg.appendChild(textSvgElement);
                textSvgElement.addEventListener('dblclick', () => {
                    this.stateManager.removeStateItem(id);
                    textSvgElement.remove();
                });
                return;
            }
            const polygon = document.getElementById(id);
            if (stateItem.looted) {
                polygon.setAttribute("stroke-dasharray", "2");
            } else {
                polygon.setAttribute("stroke-dasharray", "none");
            }
            if (stateItem.survivor) {
                polygon.setAttribute("stroke", "rgb(125,0,0)");
                polygon.setAttribute("stroke-width", "2");
            } else {
                polygon.setAttribute("stroke", "rgb(0,0,0)");
                polygon.setAttribute("stroke-width", "2");
            }
            if (stateItem.base) {
                polygon.setAttribute("stroke", "rgb(0,125,0)");
                polygon.setAttribute("stroke-dasharray", "none");
                polygon.setAttribute("stroke-width", "2");
            } else {
                if (stateItem.survivor) {
                    polygon.setAttribute("stroke", "rgb(125,0,0)");
                    polygon.setAttribute("stroke-width", "2");
                } else {
                    polygon.setAttribute("stroke", "rgb(0,0,0)");
                    polygon.setAttribute("stroke-width", "1");
                }
            }

        }
    }

    window.PolygonManager = PolygonManager;
}())
</script>
    <script>(function () {
    class SvgManager {
        constructor(svg, popover) {
            const buildings = svg.querySelectorAll("polygon[k='building']")

            svg.addEventListener("click", function (e) {
                popover.hide();
                popover.locked = false;
                if (openId) {
                    document.getElementById(openId).setAttribute("fill", openIdFill);
                }
            });
            let openId;
            let openIdFill;
            buildings.forEach(building => building.addEventListener("click", function (e) {
                popover.locked = true;
                popover.show(building.id);
                if (openId) {
                    document.getElementById(openId).setAttribute("fill", openIdFill);
                }
                openIdFill = building.getAttribute("fill");
                openId = building.id;
                building.setAttribute("fill", "rgb(0,0,0)");
                e.stopPropagation();
            }))

            buildings.forEach(building => building.addEventListener("mouseover", function (e) {
                if (!popover.locked) {
                    popover.show(building.id);
                    if (openId) {
                        document.getElementById(openId).setAttribute("fill", openIdFill);
                    }
                    openIdFill = building.getAttribute("fill");
                    openId = building.id;
                    building.setAttribute("fill", "rgb(0,0,0)");
                }
            }))

            buildings.forEach(building => building.addEventListener("mouseout", function (e) {
                if (!popover.locked) {
                    popover.hide();
                    if (openId) {
                        document.getElementById(openId).setAttribute("fill", openIdFill);
                    }
                    openId = null
                    openIdFill = null;
                }
            }));

            document.querySelectorAll("legend").forEach(x => x.addEventListener('click', function () {
                const parent = x.parentNode;
                parent.classList.toggle("collapsed");
            }));
        }
    }

    window.SvgManager = SvgManager;
}())</script>
    <script>(async function () {
    function setupReset() {
        const saveManagerNewLabel = document.querySelector("#save-manager legend")
        let tapCounter = 0;
        let timeout;
        saveManagerNewLabel.addEventListener('touchstart', function () {
            tapCounter++;
            clearTimeout(timeout);
            timeout = setTimeout(() => tapCounter = 0, 1000);
        });
        saveManagerNewLabel.addEventListener('touchend', function () {
            if (tapCounter > 8) {
                if (confirm("Delete all saved data?")) {
                    localStorage.clear();
                    window.location.reload();
                }
            }
        });
        saveManagerNewLabel.addEventListener('mousedown', function () {
            tapCounter++;
            clearTimeout(timeout);
            timeout = setTimeout(() => tapCounter = 0, 1000);
        });
        saveManagerNewLabel.addEventListener('mouseup', function () {
            if (tapCounter > 8) {
                if (confirm("Delete all saved data?")) {
                    localStorage.clear();
                    window.location.reload();
                }
            }
        });
    }

    setupReset();
    const queryState = new QueryState();
    async function loadVersion(version) {
        const infoFile = await fetch(`b${version}-info.json`).then(x => x.json());
        const metadataFile = await fetch(`b${version}-metadata.json`).then(x => x.json());
        const svgFile = await fetch(`b${version}-svg.svg`).then(x => x.text());
        return { infoFile, metadataFile, svgFile };
    }
    async function initApp(svgContainer, info, metadata, version) {
        const svg = svgContainer.querySelector("svg");
        const stateManager = new StateManager(version);
        const polygonManager = new PolygonManager(svg, stateManager);
        const textAnnotater = new TextAnnotater(svg, version);
        const mapConfig = {
            width: info.mapWidth,
            height: info.mapHeight,
            zoomLevels: [0, 1, 2, 3, 4, 5, 6, 7],
            zoomFunction: (x) => Math.pow(2, x),
            controls: {
                keys: true,
                buttons: true,
                mouse: true
            },
            initialZoom: 1
        }
        const mapSvg = new MapSvg(svg, mapConfig, queryState);
        const locator = new Locator(svg, metadata, mapSvg);
        const popover = new Popover(svg, stateManager, metadata, polygonManager, locator, info)
        const saveManager = new SaveManager(stateManager, popover, polygonManager);
        const toolbar = new Toolbar(stateManager, svg, mapSvg, polygonManager);
        const svgManager = new SvgManager(svg, popover);
    }
    async function startApp(svgContainer, version) {
        const svg = svgContainer.querySelector("svg");
        if (svg) {
            svg.remove();
        }
        
        const { infoFile, metadataFile, svgFile } = await loadVersion(version);
        const currentSvgContainerContent = svgContainer.innerHTML;
        const newInnerHTML = svgFile + currentSvgContainerContent;
        svgContainer.innerHTML = newInnerHTML;
        await initApp(svgContainer, infoFile, metadataFile, version);
        const versionSelectorSelect = document.getElementById("version-selector-select");
        versionSelectorSelect.value = version;
        queryState.updateQuery({ v: version });
        versionSelectorSelect.addEventListener('change', () => {
            const version = versionSelectorSelect.value;
            startApp(svgContainer, version);
        });
    }

    const svgContainer = document.getElementById("svg-container");
    const versions = await fetch("versions.json").then(x => x.json());
    const versionSelectorSelect = document.getElementById("version-selector-select");
    let version = versions[0];
    const queryVersion = queryState.state.v;
    if (queryVersion && queryVersion.length) {
        version = +queryVersion;
    }
    for (const ver of versions) {
        const option = document.createElement("option");
        option.value = ver;
        option.innerHTML = "Build " + ver;
        option.selected = version == ver;
        versionSelectorSelect.appendChild(option);
    }
    
    
    await startApp(svgContainer, version);
}());

</script>
</body>
</html>